https://ac.nowcoder.com/acm/problem/226831

本题是一道很经典的问题LIS，虽然是DP模板题，但是DP只能给到On^2的复杂度，并非最优解，想要AC用到贪心的思想。

现在给出贪心解法：我们去维护一个tails数组，tails[i]表示长度为i+1的LIS的结尾的元素，每输入一个元素我们通过二分查找tails数组，找到第一个大于等于当前元素的位置，如果是末尾则可以之间插入（因为可以优化我们的答案），如果不是末尾直接替换掉，因为这样的话后面就更好插入了，也就是贪心的思想。

模拟一下
比如说[1,1,3,2,1]
i=0: 1插入末尾
i=1: 1替换1
i=2: 3插入末尾
i=3: 2替换3，长度为2的更好更新一点
i=4: 1替换1, 也就是长度为1的结尾替换掉。

如果本题不是严格上升呢，那么如果结尾和目前元素相同的话可以直接保留结尾，也就是我们可以去找upper_bound.